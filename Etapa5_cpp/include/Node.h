/**
 * Class for modeling the Abstract Syntax Tree constructed during syntatic and 
 * semantic analysis of the input program. Contains methods for creating, removing 
 * and accessing nodes related to each of the accepted language's possible 
 * constructions. This class also contains private functions for generating 
 * intermediate code
 * 
 * Author: FÃ¡bio de Azevedo Gomes
 */

#ifndef NODE_H
#define NODE_H

#include "Token.h"
#include "Tac.h"
#include "Type.h"
#include "Manager.h"

#include <vector>
#include <sstream>
#include <string.h>

class Node
{

private:
    Token *lexval;       // This node's corresponding lexical value
    Type type;           // This node's type (Command nodes have TYPE_ANY)
    Statement statement; // This node's statement kind

    Node *next_cmd;               // The next command, after this node
    std::vector<Node *> children; // This node's children

    Node *next_elem; // Next element when this node is part of a list

    Tac *code;        // TAC Code generated for this node
    std::string temp; // Name of the temporary register synthesized for this node

public:
    /**
     * @brief Constructs a node based on provided data
     * @param lexval_    Token generated by the scanner
     * @param type_      Node's type according to language.
     * @param statement_ Node's statement kind
     */
    Node(Token *lexval_, Type type_, Statement statement_);

    /**
     * @brief Recursively deletes the tree that has this node has root
     */
    ~Node();

    /**
     * @brief Returns node information in the accorded format:  <address>, <label>;
     */
    std::string toString();

    /**
     * @brief Reconstructs the approximated code for this node, for error reports
     */
    std::string reconstruct();

    /**
     * @brief Exports all nodes of the AST
     * @returns String containing exported nodes
     */
    std::string exportNodes();

    /**
     * @brief Exports all edges for this node in the accorded format: <address>, <address>
     * @returns String containing this node's edges.
     */
    std::string exportEdges();

    /**
     * @brief Exports all edges of the AST taking this node as ROOT
     * @returns String containing exported edges
     */
    std::string exportAllEdges();

    /**
     * @brief Exports this node's code as a string
     * @returns String containing exported code
     */
    std::string exportCode();

    // SETTERS

    /**
     * @brief Inserts the new node as the last child
     * @param child Child node being inserted 
     */
    void insertChild(Node *child);

    /**
     * @brief Inserts the new node as the next command
     * @param command Command node being inserted 
     */
    void insertCommand(Node *next_cmd);

    /**
     * @brief Sets this node's type to the provided one
     * @param type New type for this node 
     */
    void setType(Type type);

    /**
     * @brief Sets this node's kind to the provided one
     * @param statement New kind for this node
     */
    void setKind(Statement statement);

    /**
     * @brief Insersts another node next to this onde, making a list of nodes
     */
    void insertNext(Node *next);

    /**
     * @brief Sets this node's temporary register 
     */
    void setTemp(std::string temp);

    /**
     * @brief Generate intermediate code for this node
     */
    void generateCode();

    // GETTERS

    /**
     * @brief Returns the indexed child for this node
     * @param index Child index [0- n]
     * @returns Pointer to the child 
     */
    Node *getChild(int index);

    /**
     * @brief Returns the next command after this node, or NULL if there is none 
     */
    Node *getNextCommand();

    /**
     * @brief Returns the next element after this node in a lista, or NULL if there is none 
     */
    Node *getNextElement();

    /**
     * @brief Retruns the name for this node 
     */
    const char *getName();

    /**
     * @brief Returns the type for this node 
     */
    Type getType();

    /**
     * @brief Returns the line where this node occurred
     */
    int getLine();

    /**
     * @brief Returns the node lexical value 
     */
    Token *getValue();

    /**
     * @brief Returns the node statement kind
     */
    Statement getKind();
    /**
     * @brief Returns information in a string about this node's variables and metrics
     */
    std::string getInfo();

    /**
     * @brief Returns the temporary register name created for this node
     */
    std::string getTemp();

private:
    // TAC GENERATION

    /**
     * @brief Creates a TAC sequence for accessing a vector
     */
    Tac *generateVectorAccessTAC();
};

#endif
