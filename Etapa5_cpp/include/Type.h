/**
 * This file contains enums used throughout the compiler for categorizing tokens
 * and symbols for later evaluation, ranging from type compatibility to command
 * compatibility evaluation.
 * 
 * Author: FÃ¡bio de Azevedo Gomes 
 */

#ifndef ENUMS_H
#define ENUMS_H

#include <unordered_map>
#include <string>

#define SHIFT_MAX 16   // Max shift amount
#define MAX_CHILDREN 5 // Maximum number of children in a node

// Available language types
typedef enum
{
    TYPE_INT,    // Language integers
    TYPE_FLOAT,  // Language floats
    TYPE_BOOL,   // Language bools
    TYPE_CHAR,   // Language chars
    TYPE_STRING, // Language strings
    TYPE_ANY     // Any type is acceptable, for operators such as & and *

} Type;

// Available categories for tokens generated by the scanner
typedef enum
{
    CAT_SPECIAL_CHARACTER,  // Special characters such as '.' and ';'
    CAT_COMPOSITE_OPERATOR, // A composite operator, such as '<=' or '||'
    CAT_IDENTIFIER,         // An identifier, such as a variable or function name
    CAT_LITERAL,            // A literal value, such as '50' or '"foo"'
    CAT_RESERVED            // A reserved word from the language, such as 'if' and 'output'

} Category;

// Symbol natures
typedef enum
{
    NAT_IDENTIFIER, // The symbol is a simple identifier
    NAT_VECTOR,     // The symbol is a vector
    NAT_FUNCTION,   // The symbol is a function
    NAT_NONE        // The symbol has no applicable nature

} Nature;

// Recognized statement kinds
typedef enum
{
    ST_FUNCTION_DECLARATION, // A function declaration
    ST_FUNCTION_CALL,        // A function call
    ST_INIT_VARIABLE,        // A variable initialization
    ST_ATTRIB_VARIABLE,      // A variable attribution
    ST_IO,                   // An input/output command
    ST_SHIFT,                // A shift command
    ST_BREAK_CONTINUE,       // A break/continue command
    ST_RETURN,               // A return command
    ST_IF,                   // An if statement
    ST_FOR,                  // A for statement
    ST_WHILE,                // A while statement
    ST_UNOP,                 // A unary operation
    ST_BINOP,                // A binary operation
    ST_TERNOP,               // A ternary operation
    ST_OPERAND,              // An operand such as an identifier or a literal value
    ST_VECTOR_ACCESS         // An access to a vector position

} Statement;

// Instruction codes for ILOC intermediate code language
typedef enum
{
    ILOC_NOP,  // NOP
    ILOC_HALT, // HALT
    // Arithmetics
    ILOC_ADD,   // r1, r2 => r3 | r3 = r1 + r2
    ILOC_SUB,   // r1, r2 => r3 | r3 = r1 - r2
    ILOC_MULT,  // r1, r2 => r3 | r3 = r1 * r2
    ILOC_DIV,   // r1, r2 => r3 | r3 = r1 / r2
    ILOC_ADDI,  // r1, c2 => r3 | r3 = r1 + c2
    ILOC_SUBI,  // r1, c2 => r3 | r3 = r1 - c2
    ILOC_RSUBI, // r1, c2 => r3 | r3 = c2 - r1
    ILOC_MULTI, // r1, c2 => r3 | r3 = r1 * c2
    ILOC_DIVI,  // r1, c2 => r3 | r3 = r1 / c2
    ILOC_RDIVI, // r1, c2 => r3 | r3 = c2 / r1
    // Shifts
    ILOC_LSHIFT,  // r1, r2 => r3 | r3 = r1 << r2
    ILOC_LSHIFTI, // r1, c2 => r3 | r3 = r1 << c2
    ILOC_RSHIFT,  // r1, r2 => r3 | r3 = r1 >> r2
    ILOC_RSHIFTI, // r1, c2 => r3 | r3 = r1 >> c2
    // Logic
    ILOC_AND,  // r1, r2 => r3 | r3 = r1 && r2
    ILOC_ANDI, // r1, c2 => r3 | r3 = r1 && c2
    ILOC_OR,   // r1, r2 => r3 | r3 = r1 || r2
    ILOC_ORI,  // r1, c2 => r3 | r3 = r1 || c2
    ILOC_XOR,  // r1, r2 => r3 | r3 = r1 xor r2
    ILOC_XORI, // r1, c2 => r3 | r3 = r1 xor c2
    // Loads
    ILOC_LOAD,   // r1     => r2 | r2 = Mem(r1)
    ILOC_LOADI,  // c1     => r2 | r2 = c1
    ILOC_LOADAI, // r1, c2 => r3 | r3 = Mem(r1 + c2)
    ILOC_LOADA0, // r1, r2 => r3 | r3 = Mem(r1 + r2)
    // Stores
    ILOC_STORE,   // r1 => r2     | Mem(r2) = r1
    ILOC_STOREAI, // r1 => r2, c3 | Mem(r2 + c3) = r1
    ILOC_STOREAO, // r1 => r2, r3 | Mem(r2 + r3) = r1
    // Copy
    ILOC_I2I, // r1 => r2 | r2 = r1
    // Compares
    ILOC_CMP_LT, // r1, r2 => r3 | r3 = (r1 <  r2)? true : false
    ILOC_CMP_LE, // r1, r2 => r3 | r3 = (r1 <= r2)? true : false
    ILOC_CMP_EQ, // r1, r2 => r3 | r3 = (r1 == r2)? true : false
    ILOC_CMP_GE, // r1, r2 => r3 | r3 = (r1 >= r2)? true : false
    ILOC_CMP_GT, // r1, r2 => r3 | r3 = (r1 >  r2)? true : false
    ILOC_CMP_NE, // r1, r2 => r3 | r3 = (r1 != r2)? true : false
    // Jumps
    ILOC_CBR,   // r1 => l2, l3 | PC = (r1 == true)? Address(l2) | Address(l3)
    ILOC_JUMPI, // l1           | PC = Address(l1)
    ILOC_JUMP   // r1           | PC = r1

} ILOCop;

// Binop codes based on token for arithmetic operations
const std::unordered_map<std::string, ILOCop> arithmetic_binop_code = {

    // Arithmetic binary operations
    {"+", ILOC_ADD},
    {"-", ILOC_SUB},
    {"*", ILOC_MULT},
    {"/", ILOC_DIV},
    {"%", ILOC_NOP}, // ?
    {"^", ILOC_NOP}  // ?

};

// Binop codes based on token for logic and comparison operation
const std::unordered_map<std::string, ILOCop> logic_binop_code = {
    // Comparison binary operations
    {"<", ILOC_CMP_LT},
    {">", ILOC_CMP_GT},
    {"==", ILOC_CMP_EQ},
    {"<=", ILOC_CMP_LE},
    {">=", ILOC_CMP_GE},
    {"!=", ILOC_CMP_NE},
    // Logic binary operations
    {"&&", ILOC_AND},
    {"||", ILOC_OR},
    {"|", ILOC_OR}, // TODO ?
    {"&", ILOC_AND} // TODO ?

};

// Instruction names for generating code string
const std::unordered_map<ILOCop, std::string> opname = {

    {ILOC_NOP, "nop"},
    {ILOC_HALT, "halt"},
    {ILOC_ADD, "add"},
    {ILOC_SUB, "sub"},
    {ILOC_MULT, "mult"},
    {ILOC_DIV, "div"},
    {ILOC_ADDI, "addI"},
    {ILOC_SUBI, "subI"},
    {ILOC_RSUBI, "rsubI"},
    {ILOC_MULTI, "multI"},
    {ILOC_DIVI, "divI"},
    {ILOC_RDIVI, "rdivI"},
    {ILOC_LSHIFT, "lshift"},
    {ILOC_LSHIFTI, "lshiftI"},
    {ILOC_RSHIFT, "rshift"},
    {ILOC_RSHIFTI, "rshiftI"},
    {ILOC_AND, "and"},
    {ILOC_ANDI, "andI"},
    {ILOC_OR, "or"},
    {ILOC_ORI, "orI"},
    {ILOC_XOR, "xor"},
    {ILOC_XORI, "xorI"},
    {ILOC_LOAD, "load"},
    {ILOC_LOADI, "loadI"},
    {ILOC_LOADAI, "loadAI"},
    {ILOC_LOADA0, "loadA0"},
    {ILOC_STORE, "store"},
    {ILOC_STOREAI, "storeAI"},
    {ILOC_STOREAO, "storeAO"},
    {ILOC_I2I, "i2i"},
    {ILOC_CMP_LT, "cmp_LT"},
    {ILOC_CMP_LE, "cmp_LE"},
    {ILOC_CMP_EQ, "cmp_EQ"},
    {ILOC_CMP_GE, "cmp_GE"},
    {ILOC_CMP_GT, "cmp_GT"},
    {ILOC_CMP_NE, "cmp_NE"},
    {ILOC_CBR, "cbr"},
    {ILOC_JUMPI, "jumpI"},
    {ILOC_JUMP, "jump"}

};

// UTILITY FUNCTIONS

/**
 * @brief Returns the size for a given type 
 * @param type Type
 * @returns Size of that type, in bytes
 */
int getSize(Type type);

/**
 * @brief Decides if two types are compatible
 * @param type1 First type
 * @param type2 Second type
 * @returns True if compatible, false otherwise
 */
bool isCompatible(Type type1, Type type2);

/**
 * @brief Returns the name for a given type
 * @param type Type
 * @returns Name for that type 
 */
const char *getTypeName(Type type);

/**
 * @brief Infers a type, given 2 generating types
 * @param type1 First type
 * @param type2 Second type
 */
Type inferType(Type type1, Type type2);

#endif