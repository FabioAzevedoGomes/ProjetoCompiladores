/**
 * This file contains enums used throughout the compiler for categorizing tokens
 * and symbols for later evaluation, ranging from type compatibility to command
 * compatibility evaluation.
 * 
 * Author: FÃ¡bio de Azevedo Gomes 
 */

#ifndef ENUMS_H
#define ENUMS_H

#define SHIFT_MAX 16   // Max shift amount
#define MAX_CHILDREN 5 // Maximum number of children in a node

// Available language types
typedef enum
{
    TYPE_INT,    // Language integers
    TYPE_FLOAT,  // Language floats
    TYPE_BOOL,   // Language bools
    TYPE_CHAR,   // Language chars
    TYPE_STRING, // Language strings
    TYPE_ANY     // Any type is acceptable, for operators such as & and *

} Type;

// Available categories for tokens generated by the scanner
typedef enum
{
    CAT_SPECIAL_CHARACTER,  // Special characters such as '.' and ';'
    CAT_COMPOSITE_OPERATOR, // A composite operator, such as '<=' or '||'
    CAT_IDENTIFIER,         // An identifier, such as a variable or function name
    CAT_LITERAL,            // A literal value, such as '50' or '"foo"'
    CAT_RESERVED            // A reserved word from the language, such as 'if' and 'output'

} Category;

// Symbol natures
typedef enum
{
    NAT_IDENTIFIER, // The symbol is a simple identifier
    NAT_VECTOR,     // The symbol is a vector
    NAT_FUNCTION,   // The symbol is a function
    NAT_NONE        // The symbol has no applicable nature

} Nature;

// Recognized statement kinds
typedef enum
{
    ST_FUNCTION_DECLARATION, // A function declaration
    ST_FUNCTION_CALL,        // A function call
    ST_INIT_VARIABLE,        // A variable initialization
    ST_ATTRIB_VARIABLE,      // A variable attribution
    ST_IO,                   // An input/output command
    ST_SHIFT,                // A shift command
    ST_BREAK_CONTINUE,       // A break/continue command
    ST_RETURN,               // A return command
    ST_IF,                   // An if statement
    ST_FOR,                  // A for statement
    ST_WHILE,                // A while statement
    ST_UNOP,                 // A unary operation
    ST_BINOP,                // A binary operation
    ST_TERNOP,               // A ternary operation
    ST_OPERAND,              // An operand such as an identifier or a literal value
    ST_VECTOR_ACCESS         // An access to a vector position

} Statement;

// UTILITY FUNCTIONS

/**
 * @brief Returns the size for a given type 
 * @param type Type
 * @returns Size of that type, in bytes
 */
int getSize(Type type);

/**
 * @brief Decides if two types are compatible
 * @param type1 First type
 * @param type2 Second type
 * @returns True if compatible, false otherwise
 */
bool isCompatible(Type type1, Type type2);

/**
 * @brief Returns the name for a given type
 * @param type Type
 * @returns Name for that type 
 */
const char *getTypeName(Type type);

/**
 * @brief Infers a type, given 2 generating types
 * @param type1 First type
 * @param type2 Second type
 */
Type inferType(Type type1, Type type2);

#endif