/**
 * Class for modeling the Abstract Syntax Tree constructed during syntatic and 
 * semantic analysis of the input program. Contains methods for creating, removing 
 * and accessing nodes related to each of the accepted language's possible 
 * constructions. This class also contains private functions for generating 
 * intermediate code
 * 
 * Author: FÃ¡bio de Azevedo Gomes
 */

#ifndef NODE_H
#define NODE_H

#include "Token.h"
#include "Tac.h"
#include "Type.h"
#include "Manager.h"

#include <vector>
#include <sstream>
#include <string.h>
#include <list>

class Node
{

public:
    // AST

    Token *lexval;       // This node's corresponding lexical value
    Type type;           // This node's type (Command nodes have TYPE_ANY)
    Statement statement; // This node's statement kind

    Node *next_cmd;               // The next command, after this node
    std::vector<Node *> children; // This node's children

    Node *next_elem; // Next element when this node is part of a list

    // Code generation

    bool lval; // Whether this node is an lval or not

    Tac *code;         // TAC Code generated for this node
    std::string *temp; // Name of the temporary register synthesized for this node

    bool address; // Whether this node has an address in it's temporary register
    bool value;   // Whether this node has a value in it's temporary register

    std::list<std::string *> true_list;  // List of instructions with holes to be patched in case of TRUE
    std::list<std::string *> false_list; // List of instructions with holes to be patched in case of FALSE

    /**
     * @brief Constructs a node based on provided data
     * @param lexval_    Token generated by the scanner
     * @param type_      Node's type according to language.
     * @param statement_ Node's statement kind
     * @param lval_      If this node is an lval
     */
    Node(Token *lexval_, Type type_, Statement statement_, bool lval_ = true);

    /**
     * @brief Recursively deletes the tree that has this node has root
     */
    ~Node();

    /**
     * @brief Returns node information in the accorded format:  <address>, <label>;
     */
    std::string toString();

    /**
     * @brief Reconstructs the approximated code for this node, for error reports
     */
    std::string reconstruct();

    /**
     * @brief Exports all nodes of the AST
     * @returns String containing exported nodes
     */
    std::string exportNodes();

    /**
     * @brief Exports all edges for this node in the accorded format: <address>, <address>
     * @returns String containing this node's edges.
     */
    std::string exportEdges();

    /**
     * @brief Exports all edges of the AST taking this node as ROOT
     * @returns String containing exported edges
     */
    std::string exportAllEdges();

    /**
     * @brief Exports this node's code as a string
     * @returns String containing exported code
     */
    std::string exportCode();

    // SETTERS

    /**
     * @brief Inserts the new node as the last child
     * @param child Child node being inserted 
     */
    void insertChild(Node *child);

    /**
     * @brief Inserts the new node as the next command
     * @param command Command node being inserted 
     */
    void insertCommand(Node *next_cmd);

    /**
     * @brief Sets this node's type to the provided one
     * @param type New type for this node 
     */
    void setType(Type type);

    /**
     * @brief Sets this node's kind to the provided one
     * @param statement New kind for this node
     */
    void setKind(Statement statement);

    /**
     * @brief Insersts another node next to this onde, making a list of nodes
     */
    void insertNext(Node *next);

    /**
     * @brief Sets this node's temporary register 
     */
    void setTemp(std::string *temp);

    /**
     * @brief Generate intermediate code for this node
     */
    void generateCode();

    /**
     * @brief Sets this node as having an address int it's temp
     */
    void setAddress();

    /**
     * @brief Sets this node as having a value in it's temp 
     */
    void setValue();

    /**
     * @brief Sets this node as being an rval 
     */
    void setRval();

    // GETTERS

    /**
     * @brief Returns the indexed child for this node
     * @param index Child index [0- n]
     * @returns Pointer to the child 
     */
    Node *getChild(int index);

    /**
     * @brief Returns the next command after this node, or NULL if there is none 
     */
    Node *getNextCommand();

    /**
     * @brief Returns the next element after this node in a lista, or NULL if there is none 
     */
    Node *getNextElement();

    /**
     * @brief Retruns the name for this node 
     */
    const char *getName();

    /**
     * @brief Returns the type for this node 
     */
    Type getType();

    /**
     * @brief Returns the line where this node occurred
     */
    int getLine();

    /**
     * @brief Returns the node lexical value 
     */
    Token *getValue();

    /**
     * @brief Returns the node statement kind
     */
    Statement getKind();

    /**
     * @brief Returns information in a string about this node's variables and metrics
     */
    std::string getInfo();

    /**
     * @brief Returns the temporary register name created for this node
     */
    std::string *getTemp();

    /**
     * @brief Returns A COPY of the code for this register 
     */
    Tac *getCode();

    /**
     * @brief If this node has an address
     */
    bool hasAddress();

    /**
     * @brief If this node has a value
     */
    bool hasValue();

    /**
     * @brief Returns this node's true list 
     */
    std::list<std::string *> getTrueList();

    /**
     * @brief Returns this node's false list 
     */
    std::list<std::string *> getFalseList();

    /**
     * @brief CLeras this node's true list 
     */
    void clearTrueList();

    /**
     * @brief Clears this node's false list
     */
    void clearFalseList();

private:
    // TAC GENERATION

    /**
     * @brief Creates TAC sequence for accessing a variable
     * and sets the node's temp to the variable address 
     */
    Tac *generateLvalVariableTAC();

    /**
     * @brief Creates a TAC sequence for acessing the value of a variable
     * and sets the node's temp to the variable value
     */
    Tac *generateRvalVariableTAC();

    /**
     * @brief Creates a TAC sequence for accessing a vector and
     * sets the node's temp to the indexed element's address
     */
    Tac *generateLvalVectorTAC();

    /**
     * @brief Creates a TAC sequence for accesing a vector in a given index,
     * and sets the node's temp to the value of the element at that index 
     */
    Tac *generateRvalVectorTAC();

    /**
     * @brief Creates a TAC sequence for a variable initialization operation 
     */
    Tac *generateInitializationTAC();

    /**
     * @brief Creates a TAC sequence for an attribution operation
     */
    Tac *generateAttributionTAC();

    /**
     * @brief Creates a TAC sequence for a unary opration
     * @param op String with the operator 
     */
    Tac *generateUnopTAC(std::string op);

    /**
     * @brief Creates a TAC for binary operations
     * @param op String with the operator
     */
    Tac *generateBinopTAC(std::string op);

    /**
     * @brief Creates a TAC for a binary arithmetic operation
     * @param op ILOC opcode for the operation 
     */
    Tac *generateArithmeticBinopTAC(ILOCop op);

    /**
     * @brief Creates a TAC for an AND logic expression 
     */
    Tac *generateAndTAC();

    /**
     * @brief Creates a TAC for an OR logic expression 
     */
    Tac *generateOrTAC();

    /**
     * @brief Creates a TAC for a comparison logic expression
     * @param op Comparison operation
     */
    Tac *generateComparisonTAC(ILOCop op);

    /**
     * @brief Creates a TAC for a binary logic operation
     * @param op String with the operator
     */
    Tac *generateLogicBinopTAC(ILOCop op);

    /**
     * @brief Creates a TAC for a ternary operation 
     */
    Tac *generateTernopTAC();

    /**
     * @brief Creates a TAC sequence for an IF statement (no else)
     */
    Tac *generateIfTAC();

    /**
     * @brief Creates a TAC sequence for an IF-ELSE statement 
     */
    Tac *generateIfElseTAC();

    /**
     * @brief Creates a TAC sequence for a FOR statement 
     */
    Tac *generateForTAC();

    /**
     *@brief Creates a TAC sequence for a WHILE statement 
     */
    Tac *generateWhileTAC();

    /**
     * @brief Creates a TAC sequence for a SHIFT statement
     * @param op Operation code (shift left or right) 
     */
    Tac *generateShiftTAC(ILOCop op);

    /**
     * @brief Creates a TAC sequence for a function declaration
     */
    Tac *generateFunctionDeclarationTAC();

    /**
     * @brief Creates a TAC sequence for a function call 
     */
    Tac *generateFunctionCallTAC();

    /**
     * @brief Creates a TAC sequence for a return statement 
     */
    Tac *generateReturnTAC();

public:
    /**
     * @brief Creates a TAC sequence to start a program 
     * @param rsp_val  Starting address for rsp (and thus also rfp)
     * @param rbss_val Starting address for rbss (Usually code size + 1)
     */
    void generateProgramStartTAC(int rsp_val, int rbss_val);
};

#endif
